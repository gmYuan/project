{"version":3,"file":"vue.js","sources":["../../src/utils.js","../../src/observer/array.js","../../src/observer/index.js","../../src/state.js","../../src/compiler/parse.js","../../src/compiler/generate.js","../../src/compiler/index.js","../../src/init.js","../../src/index.js"],"sourcesContent":["export function isObject(val) {\n    return typeof val == 'object' && val !== null\n}\n\nexport function isFunction(val) {\n    return typeof val === 'function';\n}","// S1 拿到数组原型上的方法 （原来的方法）\nlet oldArrayProtoMethods = Array.prototype;\n\n//S2 创建新的原型基础对象：arrayMethods.__proto__ = Array.prototype\nexport let arrayMethods = Object.create(oldArrayProtoMethods);\n\n// S3 获取 数组中会改变原数组的方法\nlet methods = [\"push\", \"shift\", \"unshift\", \"pop\", \"reverse\", \"sort\", \"splice\"];\n\n// S4 调用的如果是以上七个方法，就会优先读取下面重写的，否则用原来的数组方法\nmethods.forEach((method) => {\n  // 接收参数\n  arrayMethods[method] = function (...args) {\n    //S5 要先执行原逻辑\n    const result = oldArrayProtoMethods[method].apply(this, args);\n    let inserted;\n\n    //S6 根据当前数组获取到observer实例\n    let ob = this.__ob__;\n\n    switch (method) {\n      case \"push\": // arr.push({a:1},{b:2})\n      case \"unshift\":\n        //这2个方法都是追加 追加的内容可能是对象类型，应该被再次进行劫持\n        inserted = args;\n        break;\n      case \"splice\": // vue.$set原理\n        inserted = args.slice(2); // arr.splice(0,1,{a:1},{a:1},{a:1})\n      default:\n        break;\n    }\n\n    // S7 如果有新增的内容，要进行继续劫持,\n    // 需要观测的是 数组里的每一项，而不是数组\n    if (inserted) ob.observeArray(inserted);\n\n    // S8 返回结果\n    return result;\n  };\n});\n","import { isObject } from \"../utils\";\nimport { arrayMethods } from \"./array\";\n\n// 基本原则：\n// 1.如果数据是对象：会将对象不停的递归 进行劫持\n// 2.如果是数组：会劫持数组的方法，并对数组中不是基本数据类型的 进行劫持\n\n// 劫持对象类型\nexport function observe(data) {\n  // 如果是对象才观测\n  if (!isObject(data)) {\n    return;\n  }\n  return new Observer(data);\n}\n\n// 劫持中心\nclass Observer {\n  constructor(data) {\n    // S3 在所有被劫持过的属性上，都增加 __ob__属性\n    // data.__ob__ = this;\n    Object.defineProperty(data, \"__ob__\", {\n      value: this,\n      enumerable: false, // 不可枚举的\n    });\n\n    if (Array.isArray(data)) {\n      //S2 单独处理 数组劫持的逻辑，因为数组并不能只是 简单检测它的key变化\n\n      //S2.1 对数组原来的方法进行改写：切片编程/高阶函数/代理模式\n      data.__proto__ = arrayMethods;\n\n      //S2.2 如果数组中的数据是对象类型，需要监控对象的变化\n      this.observeArray(data);\n    } else {\n      //S1 对对象中的所有属性 进行劫持\n      // 缺点：需要递归劫持嵌套对象的属性（增加get/set）,影响性能\n      // 所以 Vue3 改成了 proxy来监听\n      this.walk(data);\n    }\n  }\n\n  observeArray(data) {\n    // 对数组成员里的 嵌套数组/对象类型，进行递归劫持\n    data.forEach((item) => observe(item));\n  }\n\n  walk(data) {\n    Object.keys(data).forEach((key) => {\n      defineReactive(data, key, data[key]);\n    });\n  }\n}\n\n// vue2会对对象进行遍历 ==> 每个属性用defineProperty重新定义\nfunction defineReactive(data, key, value) {\n  observe(value); // 处理对象嵌套 ==> 递归调用\n\n  Object.defineProperty(data, key, {\n    get() {\n      return value;\n    },\n    set(newV) {\n      // Todo 更新视图\n      console.log(\"监测到值发生了变化\");\n      //如果赋值的是一个新对象 ，也需要对这个新对象 进行劫持\n      observe(newV);\n      value = newV;\n    },\n  });\n}\n","import { observe } from \"./observer/index\";\n\nexport function initState(vm) {\n    const opts = vm.$options;\n    if (opts.props) {\n        initProps(vm);\n    }\n    if (opts.methods) {\n        initMethods(vm);\n    }\n    if (opts.data) {\n        initData(vm);\n    }\n    if (opts.computed) {\n        initComputed(vm);\n    }\n    if (opts.watch) {\n        initWatch(vm);\n    }\n}\n\nfunction initProps() {}\n\nfunction initMethods() {}\n\nfunction initData(vm) {\n    let data = vm.$options.data;\n    // 把data结果 挂载到 vue._data上\n    vm._data = data = typeof data == 'function'? data.call(vm):data;\n\n    //S3 数据劫持/响应式原理\n    // Vue2: 对象==> Object.defineProperty; 数组==> 单独处理\n\n    // 当我去vm上取属性时 ，帮我将属性的取值代理到vm._data上\n    // for(let key in data){\n    //     proxy(vm,'_data',key);\n    // } \n    observe(data);\n}\n\nfunction initComputed() {}\n\nfunction initWatch() {}","// 关于正则可视化，参见：https://jex.im/regulex/#!flags=&re=\n\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; // 标签名\n// ?:匹配不捕获\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\n\n//S1 标签开头的正则 捕获的内容是标签名\nconst startTagOpen = new RegExp(`^<${qnameCapture}`);\n// console.log('开始标签是', startTagOpen)\n// console.log('开始标签测试结果是', '<my_name//:is_ygm>'.match(startTagOpen))\n\n//S2 匹配标签结尾的 </div>\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`);\n// console.log('结束标签是', endTag)\n\n//S3 匹配属性 aaa=\"aaa\"  a='aaa'   a=aaa\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n\n//S4 匹配标签的右箭头>\nconst startTagClose = /^\\s*(\\/?)>/;\n\n//S5 匹配Vue里的变量模版 双大括号 {{ }}\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n\n\n/**\n作用: 把html模板内容转化为 AST节点对象\n\n流程:\nS1 解析模板内的 标签： startTagMatch / endTagMatch\n  - startTagMatch: parseStartTag + start\n  - endTagMatch: end +  advance\n \nS2 解析模板内的 文本：chars + advance  \n\nS3.1 parseStartTag: 获取tagName 和 tag属性 信息\nS3.2 start: 创建 root + 创建AstElement并入栈 + 更新currentParent\nS3.3 chars: 创建 文本类型的AstElement + 作为currentParent.children\nS3.4 end: 利用html文档标签的天然栈性质，创建节点之间的 父子关系\n*/\n\nlet root;\nlet currentParent;\nlet stack = [];\nlet html;\n\nexport function parseHTML(sourceHTML) {\n  html = sourceHTML;\n  while (html) {\n    //只要html不为空字符串就一直解析\n    let textEnd = html.indexOf(\"<\"); // 当前解析的开头\n    // S1 说明是标签(开始/结束标签) ==> 处理标签\n    if (textEnd == 0) {\n      // 解析开始标签\n      const startTagMatch = parseStartTag();\n      if (startTagMatch) {\n        start(startTagMatch.tagName, startTagMatch.attrs);\n        continue;\n      }\n      // 解析结束标签\n      const endTagMatch = html.match(endTag);\n      if (endTagMatch) {\n        advance(endTagMatch[0].length);\n        end(endTagMatch[1]);\n        continue;\n      }\n    }\n    //S2 处理文本\n    let text;\n    if (textEnd > 0) {\n      text = html.substring(0, textEnd);\n    }\n    if (text) {\n      advance(text.length);\n      chars(text);\n    }\n  }\n  // console.log('root是', root)\n  return root;\n}\n\n// 将字符串进行截取操作 + 更新html内容\nfunction advance(len) {\n  html = html.substring(len);\n}\n\n// 处理开始标签\nfunction parseStartTag() {\n  const start = html.match(startTagOpen);\n  if (start) {\n    const match = {\n      tagName: start[1],\n      attrs: [],\n    };\n    // 删除开始标签左半部分：<div id='app'> 中的 <div\n    advance(start[0].length);\n\n    let end;\n    let attr;\n    // 如果没有遇到开始标签的结尾，就不停的解析\n    // 能匹配到属性\n    while (\n      !(end = html.match(startTagClose)) &&\n      (attr = html.match(attribute))\n    ) {\n      // 保存属性值\n      match.attrs.push({ name: attr[1], value: attr[3] || attr[4] || attr[5] });\n      // 去掉html当前标签里的 属性\n      advance(attr[0].length);\n    }\n    // 删除匹配到的开始标签的 右结束标签 >\n    if (end) {\n      advance(end[0].length);\n    }\n    return match;\n  }\n  return false; // 不是开始标签\n}\n\nfunction start(tagName, attrs) {\n  let element = createASTElement(tagName, attrs);\n  if(!root) {\n    root = element;\n  }\n  currentParent = element;\n  stack.push(element);\n}\n\n// 处理结束标签 ==> 在结尾标签处，创建父子关系\nfunction end(tagName) {\n  let element = stack.pop();\n  currentParent = stack[stack.length-1];\n  // 在闭合时可以知道这个标签的父亲是谁\n  if(currentParent){ \n    element.parent = currentParent;\n    currentParent.children.push(element);\n  }\n}\n\n// 处理文本\nfunction chars(text) {\n  text = text.trim();\n  if(text){\n    currentParent.children.push({\n      type:3,\n      text\n    })\n  }\n}\n\n// 创建ast元素节点\nfunction createASTElement(tagName, attrs) {\n  return {\n    tag: tagName, // 标签名\n    type: 1, // 元素类型\n    attrs,\n    parent: null,\n    children: [],  \n  }\n}\n","// 核心思路就是将模板转化成 下面这段字符串\n// 即 把AST对象 转化为Render函数的 函数体\n\n// <div id=\"app\" style=\"color:red\"> <p>hello {{name}} </p> hello </div>\n// 将ast树 再次转化成js的语法\n// _c(\"div\",{id:app},_c(\"p\",undefined,_v('hello' + _s(name) )),_v('hello')) \n\n\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\n\n// 生成host元素类型标签 对应的 字符串\nexport function generate(el) {\n    let children = genChildren(el);\n    let code = `_c('${el.tag}',${\n        el.attrs.length? `${genProps(el.attrs)}`:'undefined'\n    }${\n        children?`,${children}`:''\n    })`;\n    return code;\n}\n\n\n// 拼接属性\nfunction genProps(attrs) {\n    let str = '';\n    for (let i = 0; i < attrs.length; i++) {\n        let attr = attrs[i];\n        if (attr.name === 'style') {\n            let obj = {}; // 对样式进行特殊的处理 \n            attr.value.split(';').forEach(item => {\n                let [key, value] = item.split(':');\n                obj[key] = value;\n            });\n            attr.value = obj;\n        }\n        str += `${attr.name}:${JSON.stringify(attr.value)},`;\n    }\n    return `{${str.slice(0,-1)}}`;\n}\n\n\n// 处理标签 子节点对应的 字符串\nfunction genChildren(el){\n    let children = el.children;\n    if(children && children.length > 0){\n        return `${children.map(c => gen(c)).join(',')}`\n    } else {\n        return false;\n    }\n}\n\n\nfunction gen(node){\n    // 元素类型标签， 递归调用\n    if(node.type == 1){\n        return generate(node);\n        // 处理文本节点 和 变量文本节点\n    } else {\n        // 节点内容举例: <div>a {{  name  }} b{{age}} c </div>\n        let text = node.text; \n        let tokens = [];\n        let match,index;\n        // 变量含义: 每次的偏移量\n        // 正则特性: 只要是全局匹配 就需要将lastIndex每次匹配的时候调到0处\n        let lastIndex = defaultTagRE.lastIndex = 0; \n        while(match = defaultTagRE.exec(text)){\n            index = match.index;\n            // 纯文本类型\n            if(index > lastIndex){\n                tokens.push(JSON.stringify(text.slice(lastIndex,index)));\n            }\n            // 变量文本类型\n            tokens.push(`_s(${match[1].trim()})`);\n            lastIndex = index + match[0].length;\n        }\n        // 剩余的 纯文本类型\n        if(lastIndex < text.length){\n            tokens.push(JSON.stringify(text.slice(lastIndex)))\n        }\n        return `_v(${tokens.join('+')})`;\n    }\n}","import { parseHTML } from \"./parse\";\nimport { generate } from \"./generate\";\n\n// 作用：把 html模板 => render函数\n// 流程: html转化为AST => with + new Function\nexport function compileToFunctions(template) {\n  //1. 把html代码转化成 \"ast\"语法 （ast树，可以用来描述语言本身）\n  let ast = parseHTML(template);\n\n  //2. 字符串拼接(模板引擎), 生成函数体\n  let fnBody = generate(ast);\n   \n  // 3. 注入变量上下文环境 new Function + with\n  let renderFn = new Function(`with(this){ return ${fnBody}}`); \n\n  // vue的render函数执行，返回的就是虚拟dom\n  console.log('render--', renderFn)\n  return renderFn;\n}\n","import { initState } from \"./state\";\nimport { compileToFunctions } from \"./compiler/index\";\n\nexport function initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    const vm = this;\n    vm.$options = options;\n\n    // S2 对初始化数据的类型进行 逻辑细分 ==> Props/ Data/ Computed等\n    initState(vm);\n\n    // S3 准备模板编译\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n\n  // S3 编译过程\n  // 把模板转化成 对应的渲染函数render ==>\n  // 虚拟dom vnode: 增加额外的对象属性 && 用diff算法来 更新虚拟dom ==>\n  // 生成真实dom\n  Vue.prototype.$mount = function (el) {\n    const vm = this;\n    const options = vm.$options;\n    el = document.querySelector(el);\n    vm.$el = el;\n\n    // 编译优先级： render方法 > template属性 > el的内容\n    if (!options.render) {\n      let template = options.template;\n      if (!template && el) {\n        // 也没有传递template 就取el的内容作为模板\n        template = el.outerHTML;\n      }\n      //S3.1 将模板编译成render函数\n      const render = compileToFunctions(template);\n      options.render = render;\n    }\n  };\n}\n","// 入口：对Vue进行声明和扩展\nimport { initMixin } from \"./init\";\n\nfunction Vue(options){\n   //S1 初始化数据\n   this._init(options); \n}\n\n//代码技巧：对Vue对象的 原型进行扩展==> 写成一个个的插件，从而解偶代码\ninitMixin(Vue);\n\nexport default Vue;"],"names":["isObject","val","oldArrayProtoMethods","Array","prototype","arrayMethods","Object","create","methods","forEach","method","args","result","apply","inserted","ob","__ob__","slice","observeArray","observe","data","Observer","defineProperty","value","enumerable","isArray","__proto__","walk","item","keys","key","defineReactive","get","set","newV","console","log","initState","vm","opts","$options","props","initData","computed","watch","_data","call","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","root","currentParent","stack","html","parseHTML","sourceHTML","textEnd","indexOf","startTagMatch","parseStartTag","start","tagName","attrs","endTagMatch","match","advance","length","end","text","substring","chars","len","attr","push","name","element","createASTElement","pop","parent","children","trim","type","tag","defaultTagRE","generate","el","genChildren","code","genProps","str","i","obj","split","JSON","stringify","map","c","gen","join","node","tokens","index","lastIndex","exec","compileToFunctions","template","ast","fnBody","renderFn","Function","initMixin","Vue","_init","options","$mount","document","querySelector","$el","render","outerHTML"],"mappings":"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"}